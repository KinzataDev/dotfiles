# #!/usr/bin/perl
snippet #!
	#!/usr/bin/env perl

# Hash Pointer
snippet .
	 =>
# Function
snippet sub
	sub ${1:function_name} {
		${2:#body ...}
	}
# Conditional
snippet if
	if (${1}) {
		${2:# body...}
	}
# Conditional if..else
snippet ife
	if (${1}) {
		${2:# body...}
	}
	else {
		${3:# else...}
	}
# Conditional if..elsif..else
snippet ifee
	if (${1}) {
		${2:# body...}
	}
	elsif (${3}) {
		${4:# elsif...}
	}
	else {
		${5:# else...}
	}
# Conditional One-line
snippet xif
	${1:expression} if ${2:condition};${3}
# Unless conditional
snippet unless
	unless (${1}) {
		${2:# body...}
	}
# Unless conditional One-line
snippet xunless
	${1:expression} unless ${2:condition};${3}
# Try/Except
snippet eval
	eval {
		${1:# do something risky...}
	};
	if ($@) {
		${2:# handle failure...}
	}
# While Loop
snippet wh
	while (${1}) {
		${2:# body...}
	}
# While Loop One-line
snippet xwh
	${1:expression} while ${2:condition};${3}
# C-style For Loop
snippet cfor
	for (my $${2:var} = 0; $$2 < ${1:count}; $$2${3:++}) {
		${4:# body...}
	}
# For loop one-line
snippet xfor
	${1:expression} for @${2:array};${3}
# Foreach Loop
snippet for
	foreach my $${1:x} (@${2:array}) {
		${3:# body...}
	}
# Foreach Loop One-line
snippet fore
	${1:expression} foreach @${2:array};${3}
# Package
snippet cl
	package ${1:ClassName};

	use base qw(${2:ParentClass});

	sub new {
		my $class = shift;
		$class = ref $class if ref $class;
		my $self = bless {}, $class;
		$self;
	}

	1;${3}
# Read File
snippet slurp
	my $${1:var};
	{ local $/ = undef; local *FILE; open FILE, "<${2:file}"; $$1 = <FILE>; close FILE }${3}

# Has
snippet has
	has '${1:name}' => (
		is		=> '${2:ro}',
		isa		=> '${3:Str}',
		lazy    => ${4:1},
		default => sub {
			${5}
		},
	);${6}

snippet mhas
	has '${1:name}' => (
		is		=> 'ro',
		isa		=> '${2:Str}',
		lazy    => 1,
		default => sub {
			my $self = shift;
			my $val${3:};
			return $val;
		},
	);${4}

snippet moose
	package ${1};

	use Moose;
	use namespace::autoclean;

	${2}

	__PACKAGE__->meta->make_immutable;

	1;

# Test Files
snippet lexi_test_file
	use strict;
	use warnings;

	use Test::Lexi qw/
	fixtures
	/;

	use Test::More;    # tests => 0;

	use Test::Lexi::Data::Generator qw/ create_user /;
	use Test::Lexi::WWW::Mechanize;

	fixtures(qw/db moose/);

	my $user = create_user;

	subtest "${1}" => sub {

		$mech->login($user->email);

	};

	done_testing;

snippet subtest
	subtest "${1}" => sub {
		${2}
	};

snippet tis
	is (${1:got}, ${2:expect}, ${3:name/descrption});${4}

snippet tlike
	like (${1:got}, ${2:qr/expected/}, ${3:test_name});${4}

snippet tid
	is_deeply (${1:got}, ${2:expected}, ${3:test_name});${4}

snippet lexi_mock_test
	use strict;
	use warnings;

	use Test::Lexi qw/ fixtures /;
	use Test::More tests => 1;

	use Test::Lexi::Data::${1:};

	fixtures(qw/db moose/);

	subtest 'Test $1 Mock Object' => sub {
		my $test_${2:} = Test::Lexi::Data::$1->new();

		my $$2 = $test_$2->result();

		ok( defined $$2, 'basic save is a success' );
	};

# Schemas
snippet table
	package ${1:}::Schema::Result::${2};

	# ABSTRACT: DBIC table for ${3}
	use Moose;
	use MooseX::NonMoose;
	use namespace::autoclean;

	extends '$1::Schema::Result';

	__PACKAGE__->table('${4}');
	__PACKAGE__->add_columns(
		${6}
	);

	__PACKAGE__->set_primary_key(qw/ ${5} /);

	__PACKAGE__->track_all;

	__PACKAGE__->audit_table;

	1;

snippet col
	${1} => {
		data_type         => '${2}',
	},
snippet belongs
	__PACKAGE__->belongs_to(
		${1:rel_name} => '${2:project}::Schema::Result::${3:class_name}',
		'${4:col_name}',
		{
			on_update => 'CASCADE',
		}
	);${5}

snippet in
	is_nullable => 1,${1}

# API Docs
snippet genget
	=doc_operation GET

	Summary: Retrieve ${1:}
	Notes: Retrieves ${2:}
	Model: ${3:}

snippet genpost
	=doc_operation POST

	Summary: Create ${1:}
	Notes: Create ${2:}
	Model: ${3:}

snippet genput
	=doc_operation PUT

	Summary: Update ${1:}
	Notes: Updates ${2:}
	Model: ${3:}

snippet base_POST
		my $self = shift;
		my $c    = shift;

		my ${1:} = $c->model('DB::${2}')     #
		  ->new_result( {} )                    #
		  ->save( $c->req->data );              #

		$self->status_created(
			$c,
			location => $c->uri_for( $self->action_for('${3}'), [ $1->id ] ),
			entity => {
				success => 1,
				data    => $1->REST_data,
			},
		);
		return;${4}

# Mock Object Creation
snippet mock_object
	package Test::${1:}::Data::${2:};

	use Moose;
	use namespace::autoclean;
	extends 'Test::$1::Data';

	=head1 ATTRIBUTES

	=head2 test_data

	HASH of data to use for creating a L<$1::Schema::Result::$2>

	=cut

	has 'test_data' => (
		is      => 'ro',
		isa     => 'HashRef',
		lazy    => 1,
		default => sub {
			my $self = shift;
			my $data = {
				${3:}
			};

			return $data;
		},
	);

	=head2 result

	The new test L<$1::Schema::Result::$2> object

	=cut

	has result => (
		is      => 'ro',
		isa     => '$1::Schema::Result::$2',
		lazy    => 1,
		default => sub {
			my $self = shift;
			my $obj = $self->_schema->resultset('$2')->new_result( {} )->save( $self->test_data );
			return $obj;
		},
	);

	__PACKAGE__->meta->make_immutable;

	1;

snippet mock_o
	if ( $self->${1:} ) {
		$data->{${2}} = $self->$1${3};
	}${4}
